import 'package:flutter/gestures.dart';
import 'package:flutter/widgets.dart';
import 'package:one_dollar_unistroke_recognizer/one_dollar_unistroke_recognizer.dart' as one_dollar_recognizer;
import 'package:graphilia_board/graphilia_board.dart';
import 'package:graphilia_board/src/presentation/layers/layers.dart';

class _DrawingState {
  _DrawingState() {
    initialize();
  }

  late Drawing? activeDrawing;
  late InteractionFeedback? interactionFeedback;

  void initialize() {
    activeDrawing = null;
    interactionFeedback = null;
  }
}

class DrawInteraction extends BoardInteraction {
  DrawInteraction({
    required this.tool,
    this.enableStraightLineRecognition = true,
    this.enableCircleRecognition = true,
    this.enableRectangleRecognition = true,
    this.enableTriangleRecognition = true,
  }) : _interactionState = _DrawingState();

  /// The tool that is currently selected for drawing.
  final DrawingTool tool;

  final _DrawingState _interactionState;

  final bool enableStraightLineRecognition;
  final bool enableCircleRecognition;
  final bool enableRectangleRecognition;
  final bool enableTriangleRecognition;

  BoardState _removeMouseCursor(BoardState state) {
    return state.copyWith(
      mouseCursor: SystemMouseCursors.none,
    );
  }

  BoardState _restoreMouseCursor(BoardState state) {
    return state.copyWith(
      mouseCursor: null,
    );
  }

  BoardState _setInteractionFeedback(BoardState state, CanvasPaintCallback canvasPaintCallback) {
    final previousInteractionFeedback = _interactionState.interactionFeedback;
    _interactionState.interactionFeedback = InteractionFeedback(canvasPaintCallback);

    final updatedInteractionFeedbacks = [
      ...state.interactionFeedbacks.where((e) => e != previousInteractionFeedback),
      _interactionState.interactionFeedback!,
    ];

    return state.copyWith(
      interactionFeedbacks: updatedInteractionFeedbacks,
    );
  }

  BoardState _clearInteractionFeedback(BoardState state) {
    if (_interactionState.interactionFeedback == null) return state;

    return state.copyWith(
      interactionFeedbacks: state.interactionFeedbacks.where((e) => e != _interactionState.interactionFeedback).toList(),
    );
  }

  void _drawPointer(Canvas canvas, BoardState state, BoardStateConfig config) {
    if (state.pointerPosition != null) {
      tool.drawPreview(
        canvas,
        state.pointerPosition!,
        state,
      );
    }
  }

  void _drawActiveDrawing(Canvas canvas, BoardState state, BoardStateConfig config) {
    if (_interactionState.activeDrawing is CanvasDrawing) {
      (_interactionState.activeDrawing! as CanvasDrawing).draw(
        state,
        canvas,
        simulatePressure: config.simulatePressure,
        isSelected: false,
      );
    }
  }

  BoardState disposeResources(BoardState state) {
    var updatedState = _clearInteractionFeedback(state);

    // Restore mouse cursor
    updatedState = _restoreMouseCursor(updatedState);

    // Reset the interaction state
    _interactionState.initialize();

    return updatedState;
  }

  @override
  void onRemoved(BoardNotifier notifier) {
    final state = notifier.value;

    final updatedState = disposeResources(state);

    notifier.setBoardState(
      state: updatedState,
      shouldAddToHistory: false,
    );
  }

  @override
  PointerHoverEventListenerHandler? get handlePointerHoverEvent => (
        PointerHoverEvent event,
        BoardNotifier notifier,
      ) {
        final state = notifier.value;

        // Update the mouse cursor
        var updatedState = _removeMouseCursor(state);

        // Update the interaction feedback
        updatedState = _setInteractionFeedback(updatedState, (canvas) => _drawPointer(canvas, updatedState, notifier.config));

        notifier.setBoardState(
          state: updatedState,
          shouldAddToHistory: false,
        );
        return true;
      };

  @override
  DetailedGestureScaleStartCallbackHandler get handleOnScaleStart => (
        ScaleStartDetails details,
        PointerEvent initialEvent,
        PointerEvent event,
        BoardNotifier notifier,
      ) {
        final state = notifier.value;

        final point = event.getPoint(notifier.config.pointPressureCurve).relativeToVisibleArea(state);

        final autoGeneratedId = notifier.config.idGenerator(state);
        final autoGeneratedZIndex = notifier.config.zIndexManager.read();

        final drawing = tool.createDrawing(
          point,
          autoGeneratedId,
          autoGeneratedZIndex,
          state,
        );

        _setActiveDrawing(drawing);

        // Update the interaction feedback
        final updatedState = _setInteractionFeedback(state, (canvas) => _drawActiveDrawing(canvas, state, notifier.config));

        notifier.setBoardState(
          state: updatedState,
          shouldAddToHistory: false,
        );
        return true;
      };

  @override
  DetailedGestureScaleUpdateCallbackHandler get handleOnScaleUpdate => (
        ScaleUpdateDetails details,
        PointerEvent initialEvent,
        PointerEvent event,
        BoardNotifier notifier,
      ) {
        final state = notifier.value;

        final point = event.getPoint(notifier.config.pointPressureCurve).relativeToVisibleArea(state);

        _addPointToDrawing(point, state);

        // Update the interaction feedback
        final updatedState = _setInteractionFeedback(state, (canvas) => _drawActiveDrawing(canvas, state, notifier.config));

        notifier.setBoardState(
          state: updatedState,
          shouldAddToHistory: false,
        );
        return true;
      };

  @override
  DetailedGestureScaleEndCallbackHandler get handleOnScaleEnd => (
        ScaleEndDetails details,
        PointerEvent initialEvent,
        PointerEvent event,
        BoardNotifier notifier,
      ) {
        final state = notifier.value;

        // Try to recognize the drawing;
        if (_interactionState.activeDrawing is SimpleLine) {
          final simpleLine = _interactionState.activeDrawing as SimpleLine;
          final recognizedName = simpleLine.recognizeUnistroke();
          if (recognizedName != null) {
            if (_shouldConvertDrawing(recognizedName)) {
              final newDrawing = simpleLine.tryConvertToRecognizedDrawing(
                recognizedName,
              );
              // [newDrawing] can't be null because we checked if it should be
              // converted
              _setActiveDrawing(newDrawing!);
            }
          }
        }

        var updatedState = _addActiveDrawingToSketch(state, notifier.config);

        // Update the interaction feedback
        updatedState = _clearInteractionFeedback(updatedState);

        // Reset the interaction state
        _interactionState.initialize();

        notifier.setBoardState(
          state: updatedState,
          shouldAddToHistory: true,
        );
        return true;
      };

  @override
  PointerCancelEventListenerHandler get handlePointerCancelEvent => (
        PointerCancelEvent event,
        BoardNotifier notifier,
      ) {
        var updatedState = _addActiveDrawingToSketch(notifier.value, notifier.config);

        // Update the interaction feedback
        updatedState = _clearInteractionFeedback(updatedState);

        // Reset the interaction state
        _interactionState.initialize();

        notifier.setBoardState(
          state: updatedState,
          shouldAddToHistory: false,
        );
        return true;
      };

  @override
  PointerExitEventListenerHandler get handlePointerExitEvent => (
        PointerExitEvent event,
        BoardNotifier notifier,
      ) {
        var updatedState = _addActiveDrawingToSketch(notifier.value, notifier.config);

        updatedState = disposeResources(updatedState);

        notifier.setBoardState(
          state: updatedState,
          shouldAddToHistory: false,
        );
        return true;
      };

  bool _shouldConvertDrawing(one_dollar_recognizer.DefaultUnistrokeNames name) {
    switch (name) {
      case one_dollar_recognizer.DefaultUnistrokeNames.line:
        return enableStraightLineRecognition;
      case one_dollar_recognizer.DefaultUnistrokeNames.circle:
        return enableCircleRecognition;
      case one_dollar_recognizer.DefaultUnistrokeNames.rectangle:
        return enableRectangleRecognition;
      case one_dollar_recognizer.DefaultUnistrokeNames.triangle:
        return enableTriangleRecognition;
      default:
        return false;
    }
  }

  void _setActiveDrawing(Drawing activeDrawing) {
    _interactionState.activeDrawing = activeDrawing;
  }

  void _addPointToDrawing(Point point, BoardState state) {
    if (_interactionState.activeDrawing == null) return;

    // TODO: Consider determining if the point is far enough away from the
    // last point to be considered a new point. Currently this details is
    // leave to the drawing tool.

    final updatedActiveDrawing = _interactionState.activeDrawing!.update(
      state,
      point,
    );

    if (updatedActiveDrawing == null) return;

    _interactionState.activeDrawing = updatedActiveDrawing;
  }

  BoardState _addActiveDrawingToSketch(
    BoardState state,
    BoardStateConfig config,
  ) {
    if (_interactionState.activeDrawing == null) return state;

    return state.copyWith(
      sketchDelta: SketchDelta.add(
        [_interactionState.activeDrawing!],
        state.sketchDelta.version + 1,
      ),
    );
  }
}

extension ConvertLineToOtherDrawing on SimpleLine {
  one_dollar_recognizer.DefaultUnistrokeNames? recognizeUnistroke() {
    final recognized = one_dollar_recognizer.recognizeUnistroke(representation.points);

    if (recognized == null) return null;

    if (recognized.score < 0.735) return null;

    return recognized.name;
  }

  Drawing? tryConvertToRecognizedDrawing(one_dollar_recognizer.DefaultUnistrokeNames name) {
    switch (name) {
      case one_dollar_recognizer.DefaultUnistrokeNames.line:
        return convertToStraightLine();
      case one_dollar_recognizer.DefaultUnistrokeNames.circle:
        return convertToCircleDrawing();
      case one_dollar_recognizer.DefaultUnistrokeNames.rectangle:
        return convertToRectangle();
      case one_dollar_recognizer.DefaultUnistrokeNames.triangle:
        return convertToTriangle();
      default:
        return null;
    }
  }

  SimpleStraightLine convertToStraightLine() {
    return SimpleStraightLine(
      id: id,
      zIndex: zIndex,
      representation: AnchoredDrawingRepresentation(
        anchorPoint: representation.points.first,
        endPoint: representation.points.last,
      ),
      color: color,
      width: width,
    );
  }

  SimpleCircleDrawing convertToCircleDrawing() {
    final bounds = getBounds();
    return SimpleCircleDrawing(
      id: id,
      zIndex: zIndex,
      representation: AnchoredDrawingRepresentation(
        anchorPoint: Point.fromOffset(bounds.topLeft),
        endPoint: Point.fromOffset(bounds.bottomRight),
      ),
      color: color,
      width: width,
    );
  }

  SimplePolygonDrawing convertToSquare() {
    final bounds = getBounds();
    return SimplePolygonDrawing(
      id: id,
      zIndex: zIndex,
      representation: AnchoredDrawingRepresentation(
        anchorPoint: Point.fromOffset(bounds.topLeft),
        endPoint: Point.fromOffset(bounds.bottomRight),
      ),
      color: color,
      width: width,
      polygonTemplate: squarePolygon,
    );
  }

  SimplePolygonDrawing convertToRectangle() {
    final bounds = getBounds();

    // Check if the with and height are similar by a certain threshold: 10%. If so convert it to a square
    if ((bounds.width - bounds.height).abs() < bounds.width * 0.1) {
      return convertToSquare();
    }

    return SimplePolygonDrawing(
      id: id,
      zIndex: zIndex,
      representation: AnchoredDrawingRepresentation(
        anchorPoint: Point.fromOffset(bounds.topLeft),
        endPoint: Point.fromOffset(bounds.bottomRight),
      ),
      color: color,
      width: width,
      polygonTemplate: rectanglePolygon,
    );
  }

  SimplePolygonDrawing convertToTriangle() {
    final bounds = getBounds();
    return SimplePolygonDrawing(
      id: id,
      zIndex: zIndex,
      representation: AnchoredDrawingRepresentation(
        anchorPoint: Point.fromOffset(bounds.topLeft),
        endPoint: Point.fromOffset(bounds.bottomRight),
      ),
      color: color,
      width: width,
      // TODO: Change it to a generic triangle polygon
      polygonTemplate: isoscelesTrianglePolygon,
    );
  }
}
